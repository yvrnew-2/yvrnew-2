import React, { useState, useEffect } from 'react';
import { Card, Switch, Slider, InputNumber, Row, Col, Tooltip, Space, Divider, Select } from 'antd';
import { InfoCircleOutlined, SettingOutlined } from '@ant-design/icons';

const IndividualTransformationControl = ({ 
  transformationType, 
  transformation, 
  config = {}, 
  onChange 
}) => {
  const [enabled, setEnabled] = useState(false);
  const [parameters, setParameters] = useState({});
  const [parameterRanges, setParameterRanges] = useState({});
  const [rangeEnabledParams, setRangeEnabledParams] = useState([]);

  // Initialize parameters from transformation definition and current config
  useEffect(() => {
    const initialParams = {};
    const initialRanges = {};
    
    if (transformation.parameters) {
      Object.entries(transformation.parameters).forEach(([key, paramDef]) => {
        initialParams[key] = config[key] !== undefined ? config[key] : paramDef.default;
        
        // Initialize ranges from config or create default ranges
        if (config.ranges && config.ranges[key]) {
          initialRanges[key] = config.ranges[key];
        } else {
          // Create default range based on current single value
          const currentValue = config[key] !== undefined ? config[key] : paramDef.default;
          initialRanges[key] = getDefaultRange(key, currentValue, paramDef);
        }
      });
    }
    
    setParameters(initialParams);
    setParameterRanges(initialRanges);
    
    // Set enabled state based on config, defaulting to false for new transformations
    setEnabled(config.enabled === true);
    
    // Initialize range-enabled parameters from config
    setRangeEnabledParams(config.rangeEnabledParams || []);
  }, [transformation, config]);

  // Update parent when configuration changes
  useEffect(() => {
    const newConfig = {
      enabled,
      ...parameters,
      ranges: parameterRanges,
      rangeEnabledParams
    };
    onChange(newConfig);
  }, [enabled, parameters, parameterRanges, rangeEnabledParams, onChange]);

  const handleParameterChange = (paramKey, value) => {
    setParameters(prev => {
      const newParams = {
        ...prev,
        [paramKey]: value
      };
      
      // Special handling for resize preset resolution
      if (paramKey === 'preset_resolution' && transformationType === 'resize' && value !== 'custom') {
        try {
          const [width, height] = value.split('x').map(Number);
          if (!isNaN(width) && !isNaN(height)) {
            newParams.width = width;
            newParams.height = height;
          }
        } catch (error) {
          console.warn('Failed to parse preset resolution:', value);
        }
      }
      
      return newParams;
    });
  };

  const handleRangeChange = (paramKey, rangeValues) => {
    setParameterRanges(prev => ({
      ...prev,
      [paramKey]: rangeValues
    }));
  };

  const toggleRangeMode = (paramKey, enabled) => {
    if (enabled) {
      setRangeEnabledParams(prev => [...prev, paramKey]);
    } else {
      setRangeEnabledParams(prev => prev.filter(key => key !== paramKey));
    }
  };

  // Helper function to get default range for a parameter
  const getDefaultRange = (paramKey, currentValue, paramDef) => {
    // For brightness and contrast, use +/- range around 1.0
    if (paramKey === 'brightness' || paramKey === 'contrast') {
      const defaultValue = 1.0;
      const currentVal = currentValue || defaultValue;
      // If current value is 1.0, use -20% to +20% range
      if (currentVal === defaultValue) {
        return [0.8, 1.2]; // -20% to +20% around normal
      }
      // Otherwise center the range around current value
      const rangeSize = 0.4; // Total range size
      return [
        Math.max(paramDef.min || 0.5, currentVal - rangeSize/2), 
        Math.min(paramDef.max || 2.0, currentVal + rangeSize/2)
      ];
    }
    
    // For rotation, use symmetric range around 0
    if (paramKey === 'rotation') {
      const currentVal = currentValue || 0;
      // If current value is 0, use -30 to +30 range
      if (currentVal === 0) {
        return [-30, 30];
      }
      // Otherwise center the range around current value
      const rangeSize = 60; // Total range size in degrees
      return [
        Math.max(paramDef.min || -180, currentVal - rangeSize/2),
        Math.min(paramDef.max || 180, currentVal + rangeSize/2)
      ];
    }
    
    // For scale, use range around 100%
    if (paramKey === 'scale') {
      const defaultValue = 100;
      const currentVal = currentValue || defaultValue;
      // If current value is 100%, use 80% to 120% range
      if (currentVal === defaultValue) {
        return [80, 120];
      }
      // Otherwise center the range around current value
      const rangeSize = 40; // Total range size in percentage points
      return [
        Math.max(paramDef.min || 50, currentVal - rangeSize/2), 
        Math.min(paramDef.max || 150, currentVal + rangeSize/2)
      ];
    }
    
    // Default behavior for other parameters
    if (currentValue !== undefined) {
      // Create a range of +/- 20% around current value
      const rangeSize = Math.abs(currentValue * 0.4);
      const min = paramDef.min !== undefined ? paramDef.min : (currentValue - rangeSize/2);
      const max = paramDef.max !== undefined ? paramDef.max : (currentValue + rangeSize/2);
      return [
        Math.max(min, currentValue - rangeSize/2),
        Math.min(max, currentValue + rangeSize/2)
      ];
    }
    
    // Fallback to parameter definition defaults
    return [
      paramDef.default !== undefined ? paramDef.default : (paramDef.min || 0),
      paramDef.default !== undefined ? paramDef.default : (paramDef.max || 1)
    ];
  };

  // Helper function to get appropriate unit label
  const getUnitLabel = (paramKey, paramDef) => {
    const unitMap = {
      brightness: "× (multiplier)",
      contrast: "× (multiplier)",
      rotation: "° (degrees)",
      scale: "% (percent)",
      blur: "px (pixels)",
      // Add more as needed
    };
    
    return unitMap[paramKey] || paramDef.unit || "";
  };

  // Format value for display
  const formatValue = (paramKey, val) => {
    // For brightness and contrast, show +/- percentages relative to 1.0
    if (paramKey === 'brightness' || paramKey === 'contrast') {
      const relativeVal = ((val - 1.0) * 100).toFixed(0);
      return relativeVal > 0 ? `+${relativeVal}%` : `${relativeVal}%`;
    }
    
    // For rotation, show degrees
    if (paramKey === 'rotation') {
      return `${val}°`;
    }
    
    // For scale, show as percentage
    if (paramKey === 'scale') {
      return `${val}%`;
    }
    
    // Default formatting
    return val.toFixed(2);
  };

  const renderRangeSlider = (paramKey, paramDef) => {
    // Get range values with appropriate defaults
    const [minValue, maxValue] = parameterRanges[paramKey] || 
      getDefaultRange(paramKey, parameters[paramKey], paramDef);
    
    // Get appropriate unit label
    const unitLabel = getUnitLabel(paramKey, paramDef);
    
    // For brightness and contrast, show +/- values relative to 1.0
    const showRelativeValues = (paramKey === 'brightness' || paramKey === 'contrast');
    
    return (
      <div style={{ marginBottom: 12 }}>
        <div style={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          marginBottom: 4
        }}>
          <span style={{ fontSize: '12px', fontWeight: 500 }}>
            {paramKey.charAt(0).toUpperCase() + paramKey.slice(1)}
            <span style={{ fontSize: '10px', color: '#999', marginLeft: 4 }}>
              {unitLabel}
            </span>
          </span>
          <Space>
            <Tooltip title={`Min: ${formatValue(paramKey, minValue)}`}>
              <InputNumber
                size="small"
                value={minValue}
                min={paramDef.min}
                max={maxValue}
                step={paramDef.step || 0.1}
                onChange={(val) => handleRangeChange(paramKey, [val, maxValue])}
                disabled={!enabled}
                style={{ width: 60 }}
              />
            </Tooltip>
            <span>-</span>
            <Tooltip title={`Max: ${formatValue(paramKey, maxValue)}`}>
              <InputNumber
                size="small"
                value={maxValue}
                min={minValue}
                max={paramDef.max}
                step={paramDef.step || 0.1}
                onChange={(val) => handleRangeChange(paramKey, [minValue, val])}
                disabled={!enabled}
                style={{ width: 60 }}
              />
            </Tooltip>
          </Space>
        </div>
        
        {/* For brightness and contrast, show marks at -20%, 0%, +20% */}
        {showRelativeValues ? (
          <Slider
            range
            value={[minValue, maxValue]}
            min={paramDef.min}
            max={paramDef.max}
            step={paramDef.step || 0.1}
            onChange={(val) => handleRangeChange(paramKey, val)}
            disabled={!enabled}
            tooltip={{ 
              formatter: (val) => formatValue(paramKey, val) 
            }}
            marks={{
              0.8: '-20%',
              1.0: 'Normal',
              1.2: '+20%'
            }}
            style={{ margin: '4px 0' }}
          />
        ) : (
          <Slider
            range
            value={[minValue, maxValue]}
            min={paramDef.min}
            max={paramDef.max}
            step={paramDef.step || 0.1}
            onChange={(val) => handleRangeChange(paramKey, val)}
            disabled={!enabled}
            tooltip={{ 
              formatter: (val) => formatValue(paramKey, val) 
            }}
            style={{ margin: '4px 0' }}
          />
        )}
      </div>
    );
  };

  const renderParameterControl = (paramKey, paramDef) => {
    // Check if range mode is enabled for this parameter
    const isRangeMode = rangeEnabledParams.includes(paramKey);
    
    // If range mode is enabled, render the range slider
    if (isRangeMode) {
      return renderRangeSlider(paramKey, paramDef);
    }
    
    // Otherwise, render the original single-value control
    const value = parameters[paramKey];
    
    switch (paramDef.type) {
      case 'bool':
        return (
          <div style={{ marginBottom: 12 }}>
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              alignItems: 'center',
              marginBottom: 4
            }}>
              <span style={{ fontSize: '12px', fontWeight: 500 }}>
                {paramKey.charAt(0).toUpperCase() + paramKey.slice(1)}
              </span>
              <Switch
                size="small"
                checked={value}
                onChange={(checked) => handleParameterChange(paramKey, checked)}
                disabled={!enabled}
              />
            </div>
          </div>
        );

      case 'int':
        return (
          <div style={{ marginBottom: 12 }}>
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              alignItems: 'center',
              marginBottom: 4
            }}>
              <span style={{ fontSize: '12px', fontWeight: 500 }}>
                {paramKey.charAt(0).toUpperCase() + paramKey.slice(1)}
              </span>
              <Space>
                <InputNumber
                  size="small"
                  value={value}
                  min={paramDef.min}
                  max={paramDef.max}
                  step={1}
                  onChange={(val) => handleParameterChange(paramKey, val)}
                  disabled={!enabled}
                  placeholder={paramDef.placeholder}
                  style={{ width: 70 }}
                />
                <Tooltip title="Enable range mode">
                  <Switch
                    size="small"
                    checked={isRangeMode}
                    onChange={(checked) => toggleRangeMode(paramKey, checked)}
                    disabled={!enabled}
                  />
                </Tooltip>
              </Space>
            </div>
            {paramDef.min !== undefined && paramDef.max !== undefined && (
              <Slider
                value={value}
                min={paramDef.min}
                max={paramDef.max}
                step={1}
                onChange={(val) => handleParameterChange(paramKey, val)}
                disabled={!enabled}
                tooltip={{ formatter: null }}
                style={{ margin: '4px 0' }}
              />
            )}
          </div>
        );

      case 'float':
        const step = paramDef.step || 0.1;
        return (
          <div style={{ marginBottom: 12 }}>
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              alignItems: 'center',
              marginBottom: 4
            }}>
              <span style={{ fontSize: '12px', fontWeight: 500 }}>
                {paramKey.charAt(0).toUpperCase() + paramKey.slice(1)}
                <span style={{ fontSize: '10px', color: '#999', marginLeft: 4 }}>
                  {getUnitLabel(paramKey, paramDef)}
                </span>
              </span>
              <Space>
                <InputNumber
                  size="small"
                  value={value}
                  min={paramDef.min}
                  max={paramDef.max}
                  step={step}
                  precision={2}
                  onChange={(val) => handleParameterChange(paramKey, val)}
                  disabled={!enabled}
                  style={{ width: 70 }}
                />
                <Tooltip title="Enable range mode">
                  <Switch
                    size="small"
                    checked={isRangeMode}
                    onChange={(checked) => toggleRangeMode(paramKey, checked)}
                    disabled={!enabled}
                  />
                </Tooltip>
              </Space>
            </div>
            {paramDef.min !== undefined && paramDef.max !== undefined && (
              <Slider
                value={value}
                min={paramDef.min}
                max={paramDef.max}
                step={step}
                onChange={(val) => handleParameterChange(paramKey, val)}
                disabled={!enabled}
                tooltip={{ 
                  formatter: (val) => formatValue(paramKey, val) 
                }}
                style={{ margin: '4px 0' }}
              />
            )}
          </div>
        );

      case 'select':
        return (
          <div style={{ marginBottom: 12 }}>
            <div style={{ 
              display: 'flex', 
              justifyContent: 'space-between', 
              alignItems: 'center',
              marginBottom: 4
            }}>
              <span style={{ fontSize: '12px', fontWeight: 500 }}>
                {paramKey.charAt(0).toUpperCase() + paramKey.slice(1).replace(/_/g, ' ')}
              </span>
            </div>
            <Select
              size="small"
              value={value}
              onChange={(val) => handleParameterChange(paramKey, val)}
              disabled={!enabled}
              style={{ width: '100%' }}
              placeholder={`Select ${paramKey.replace(/_/g, ' ')}`}
            >
              {paramDef.options?.map(option => (
                <Select.Option key={option} value={option}>
                  {paramDef.labels?.[option] || option.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
                </Select.Option>
              ))}
            </Select>
          </div>
        );

      default:
        return null;
    }
  };

  const getTransformationIcon = (type) => {
    const iconMap = {
      resize: '📏',
      rotate: '🔄',
      flip: '🔀',
      crop: '✂️',
      brightness: '☀️',
      contrast: '🌗',
      blur: '🌫️',
      noise: '📺',
      color_jitter: '🎨',
      cutout: '⬛',
      random_zoom: '🔍',
      affine_transform: '📐',
      perspective_warp: '🏗️',
      grayscale: '⚫',
      shear: '📊',
      gamma_correction: '💡',
      equalize: '⚖️',
      clahe: '🔆'
    };
    return iconMap[type] || '⚙️';
  };

  const getTransformationDescription = (type) => {
    const descriptions = {
      resize: 'Change image dimensions',
      rotate: 'Rotate image by specified angle',
      flip: 'Flip image horizontally or vertically',
      crop: 'Randomly crop and resize image',
      brightness: 'Adjust image brightness',
      contrast: 'Adjust image contrast',
      blur: 'Apply Gaussian blur effect',
      noise: 'Add random noise to image',
      color_jitter: 'Randomly adjust color properties',
      cutout: 'Remove random rectangular regions',
      random_zoom: 'Randomly zoom in or out',
      affine_transform: 'Apply affine transformations',
      perspective_warp: 'Apply perspective distortion',
      grayscale: 'Convert to grayscale',
      shear: 'Apply shear transformation',
      gamma_correction: 'Adjust gamma values',
      equalize: 'Histogram equalization',
      clahe: 'Contrast Limited Adaptive Histogram Equalization'
    };
    return descriptions[type] || 'Apply transformation';
  };

  // Calculate the number of range-enabled parameters
  const rangeEnabledCount = rangeEnabledParams.length;

  return (
    <Card
      size="small"
      style={{
        height: '100%',
        border: enabled ? '1px solid #1890ff' : '1px solid #e8e8e8',
        borderRadius: '8px',
        backgroundColor: enabled ? '#f6ffed' : '#fafafa',
        transition: 'all 0.3s ease'
      }}
      bodyStyle={{ padding: '12px' }}
    >
      {/* Header with title and enable/disable switch */}
      <div style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'flex-start',
        marginBottom: 12
      }}>
        <div style={{ flex: 1 }}>
          <div style={{ 
            display: 'flex', 
            alignItems: 'center', 
            marginBottom: 4
          }}>
            <span style={{ fontSize: '16px', marginRight: 6 }}>
              {getTransformationIcon(transformationType)}
            </span>
            <span style={{ 
              fontSize: '14px', 
              fontWeight: 600,
              color: enabled ? '#1890ff' : '#666'
            }}>
              {transformation.name || transformationType}
            </span>
            <Tooltip title={getTransformationDescription(transformationType)}>
              <InfoCircleOutlined 
                style={{ 
                  fontSize: '12px', 
                  color: '#999', 
                  marginLeft: 4 
                }} 
              />
            </Tooltip>
          </div>
          <div style={{ 
            fontSize: '11px', 
            color: '#999',
            lineHeight: '1.3'
          }}>
            {transformation.category === 'basic' ? 'Basic' : 'Advanced'} transformation
            {rangeEnabledCount > 0 && (
              <span style={{ color: '#1890ff', marginLeft: 4 }}>
                ({rangeEnabledCount} range{rangeEnabledCount !== 1 ? 's' : ''} enabled)
              </span>
            )}
          </div>
        </div>
        <Switch
          checked={enabled}
          onChange={setEnabled}
          size="small"
        />
      </div>

      {/* Parameters */}
      {enabled && transformation.parameters && (
        <>
          <Divider style={{ margin: '8px 0' }} />
          <div style={{ opacity: enabled ? 1 : 0.5 }}>
            {transformationType === 'resize' ? (
              // Special layout for resize transformation
              <>
                {/* Preset Resolution First */}
                {transformation.parameters.preset_resolution && (
                  <div key="preset_resolution">
                    {renderParameterControl('preset_resolution', transformation.parameters.preset_resolution)}
                  </div>
                )}
                
                {/* Custom Size Inputs (only show if preset is 'custom') */}
                {parameters.preset_resolution === 'custom' && (
                  <Row gutter={8} style={{ marginBottom: 12 }}>
                    <Col span={12}>
                      {transformation.parameters.width && renderParameterControl('width', transformation.parameters.width)}
                    </Col>
                    <Col span={12}>
                      {transformation.parameters.height && renderParameterControl('height', transformation.parameters.height)}
                    </Col>
                  </Row>
                )}
                
                {/* Resize Mode */}
                {transformation.parameters.resize_mode && (
                  <div key="resize_mode">
                    {renderParameterControl('resize_mode', transformation.parameters.resize_mode)}
                  </div>
                )}
              </>
            ) : (
              // Default layout for other transformations
              Object.entries(transformation.parameters).map(([paramKey, paramDef]) => (
                <div key={paramKey}>
                  {renderParameterControl(paramKey, paramDef)}
                </div>
              ))
            )}
          </div>
        </>
      )}

      {/* Summary when disabled */}
      {!enabled && (
        <div style={{ 
          textAlign: 'center', 
          color: '#999', 
          fontSize: '11px',
          padding: '8px 0'
        }}>
          Enable to configure parameters
        </div>
      )}

      {/* Parameter count indicator */}
      {enabled && transformation.parameters && (
        <div style={{ 
          textAlign: 'center', 
          marginTop: 8,
          fontSize: '10px',
          color: '#666'
        }}>
          {Object.keys(transformation.parameters).length} parameter{Object.keys(transformation.parameters).length !== 1 ? 's' : ''}
          {rangeEnabledCount > 0 && (
            <span style={{ color: '#1890ff', marginLeft: 4 }}>
              ({rangeEnabledCount} with ranges)
            </span>
          )}
        </div>
      )}
    </Card>
  );
};

export default IndividualTransformationControl;